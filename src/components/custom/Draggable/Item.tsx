// Dependencies
import React, { createContext, ReactNode, useEffect, useState } from "react"
// Internal
import { isBetween } from "./utils"
import styles from "./draggable.module.scss"
import { useReorder } from "./Container"

interface ItemProps {
   children: ReactNode
   uniqueId: number
   draggable?: boolean
}

// Misconception uniqueId might have empty steps, index represents the actual position
/** Reorder Item */
function Item({ draggable, children }: ItemProps) {
   const [{ uniqueId, index, onDragStart, isActive, rect }, { active, hovering, activeDy }, { milestone, ...internal }] = useReorder()
   const [posY, setPosY] = useState(null) // makes posY controlled (double render)

   useEffect(() => {
      if (!rect) internal.recalculateRects() // runs on mount (makes posY available)

      const activeRef = internal.itemRefs.current[active.index]
      // Make room for empty slot (draggable new position)
      const direction = index > active.index ? -1 : 1
      const slotDy = isBetween(index, active.index, hovering.index) ? direction * activeRef?.rect.height : 0
      /** Generated by elements above */
      const offsetTop = internal.itemRefs.current.slice(0, index).reduce((totalHeight, ref) => totalHeight + ref?.rect?.height, 0)

      setPosY(isActive ? activeDy + offsetTop : offsetTop + slotDy)
   }, [index, active, activeDy])

   return (
      <>
         {/* 1 Item */}
         <div
            style={{
               // Apply Floating layout once refs have settled
               position: milestone >= 1 ? "absolute" : "relative",
               width: milestone >= 1 && rect?.width,
               height: milestone >= 1 && rect?.height,
               top: 0,
               transform: milestone >= 1 && `translateY(${posY}px)`,
            }}
            className={`z-6 ${isActive && styles.active} ${milestone >= 2 && styles.floating}`}
            onMouseDown={(e) => draggable && onDragStart(e, uniqueId)}
            ref={(node) => node && (internal.itemRefs.current[index] = { ...internal.itemRefs.current[index], node })}
         >
            <DragContext.Provider value={{ onDragStart: (e) => onDragStart(e, uniqueId), isActive }}>{children}</DragContext.Provider>
         </div>
         {/* 2 display block representation of item */}
         <div
            style={{
               display: milestone >= 1 ? "block" : "none",
               width: rect?.width,
               height: rect?.height,
               opacity: uniqueId / 10,
            }}
            className={`bg-red`}
         />
      </>
   )
}

interface DragContextProps {
   onDragStart: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void
   /** Item being dragged */
   isActive: boolean
}

/** Individual item drag context */
const DragContext = createContext<DragContextProps | undefined>(undefined)

/** Custom Drag handle */
const useDragHandle = () => {
   const context = React.useContext(DragContext)
   if (!context) throw new Error("useCustomDrag must be used within a Reorder.Item")
   return context
}

export type { ItemProps }
export { Item, useDragHandle }
