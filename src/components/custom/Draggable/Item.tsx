// Dependencies
import React, { createContext, ReactNode, useRef, useState } from "react"
// Internal
import { isBetween } from "./utils"
import styles from "./draggable.module.scss"
import { ReorderContext } from "./Container"

interface ItemProps {
   children: ReactNode
   uniqueId: number
   draggable?: boolean
}

// Misconception uniqueId might have empty steps, index represents the actual position
/** Reorder Item */
function Item({ draggable, children }: ItemProps) {
   const context = React.useContext(ReorderContext)
   if (!context) throw new Error("Item must be used within a Reorder.Container")
   const [{ index, onDragStart, uniqueId, isActive }, { activeId, hoveringIndx, activeIndx, activeDy }] = [context.item, context.state]
   const [activeRect, itemRect] = [context.itemsRef.current.rects[activeId], context.itemsRef.current.rects[uniqueId]]

   // const isBeingHovered = !isActive && hoveringId === uniqueId

   // Make room for empty slot (draggable new position)
   // const slotDy = activeId < index ? -activeRect?.height : activeRect?.height
   const direction = index > activeIndx ? -1 : 1
   const shouldMove = isBetween(index, activeIndx, hoveringIndx)
   const moveDy = shouldMove ? direction * activeRect?.height : 0

   // const isDragging = activeId !== -1

   // onDrop fake smooth positioning to new slot
   // useEffect(() => {
   //    const wrapper = wrapRef.current
   //    const itemDrop = activeId === -1

   //    if (itemDrop && wrapper && context.prevState.activeUniqueId === uniqueId) {
   //       const dropDy = context.prevState.activeDy
   //       const avgHeight = 32 // TODO: Assumes same height for all items
   //       const diffDy = (index - prevIndexRef.current) * avgHeight

   //       wrapper.style.transition = `transform 0ms linear`
   //       wrapper.style.transform = `translateY(${dropDy - diffDy}px)` // drop pos

   //       // Force a reflow
   //       requestAnimationFrame(() => {
   //          wrapper.style.transition = `transform 70ms linear` // v = d/t (distance on drop is at most avgHeight/2)
   //          wrapper.style.transform = `translateY(${0}px)`
   //       })
   //    }
   //    prevIndexRef.current = index
   // }, [activeId])

   /** Generated by elements above */
   const offsetTop = context.rectsByIndx.slice(0, index).reduce((totalHeight, current) => totalHeight + current.rect.height, 0)

   // const prevMoveDyRef = useRef(moveDy)
   // console.log(uniqueId, " at ", index, isBeingHovered, offsetTop)
   // console.log(uniqueId, isActive, wasSelected)

   return (
      <>
         {/* Item */}
         <div
            style={{
               position: "absolute",
               top: 0,
               transform: `translateY(${activeId === uniqueId ? activeDy + offsetTop : offsetTop + moveDy}px)`,
            }}
            className={`z-6 ${isActive && styles.active} ${styles.floating}`}
            onMouseDown={(e) => draggable && onDragStart(e, uniqueId)}
            ref={(node) => {
               context.itemsRef.current.nodes[uniqueId] = node
               context.itemsRef.current.indexes[uniqueId] = index
               context.itemsRef.current.uniqueIds[uniqueId] = uniqueId
            }}
         >
            <DragContext.Provider value={{ onDragStart: (e) => onDragStart(e, uniqueId), isActive }}>{children}</DragContext.Provider>
         </div>
         {/* display block representation of item */}
         <div
            ref={(node) => node && (context.slotsRef.current[uniqueId] = node)}
            style={{
               display: "block",
               width: itemRect?.width,
               height: itemRect?.height,
               opacity: uniqueId / 10,
            }}
            className={`bg-red`}
         />
      </>
   )
}
// <div
//    onMouseDown={(e) => draggable && onDragStart(e)}
//    style={{
//       height: isDragging && itemRect.height,
//       width: isDragging && itemRect.width,
//    }}
//    ref={(node) => (context.itemsRef.current.nodes[index] = node)}
// >
//    {/* Draggable Item */}
//    <div
//       className={`${isActive && styles.active} ${isDragging && styles.floating}`}
//       style={{
//          zIndex: context.prevState.activeUniqueId === uniqueId && 87,
//          position: isDragging ? "absolute" : "relative",
//          transform: `translateY(${isActive ? activeDy : moveY}px)`,
//          width: isDragging && itemRect.width,
//          height: isDragging && itemRect.height,
//       }}
//    >
//       <div ref={wrapRef}>
//          <DragContext.Provider value={{ onDragStart: (e) => onDragStart(e), isActive }}>{children}</DragContext.Provider>
//       </div>
//    </div>
// </div>

interface DragContextProps {
   onDragStart: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void
   /** Item being dragged */
   isActive: boolean
}

/** Individual item drag context */
const DragContext = createContext<DragContextProps | undefined>(undefined)

/** Custom Drag handle */
const useDragHandle = () => {
   const context = React.useContext(DragContext)
   if (!context) throw new Error("useCustomDrag must be used within a Reorder.Item")
   return context
}

export type { ItemProps }
export { Item, useDragHandle }
