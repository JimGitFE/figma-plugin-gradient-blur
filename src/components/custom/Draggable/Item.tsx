// Dependencies
import React, { act, createContext, ReactNode, RefObject, useEffect, useRef, useState } from "react"
// Internal
import { isBetween } from "./utils"
import styles from "./draggable.module.scss"
import { useReorder } from "./Container"
import { useScrollCtx } from "./CustomScroll"
import { clamp } from "@/utils"
import { useEventListener } from "@/hooks/useEventListener"

/** Required props */
interface SourceProps {
   uniqueId: number
}

interface ItemProps extends SourceProps {
   children: ReactNode
   /** Attach listener to item (alt: `use) */
   draggable?: boolean
   /** On item grab / drag clamp to container boundary */
   boundClamp?: boolean
}

// Misconception uniqueId might have empty steps, index represents the actual position
/** Reorder Item - slot sorted by uniqueId, relatively positioned by index */
function Item({ draggable, boundClamp = true, children }: ItemProps) {
   const { scrolledY, scrolledYDiff, containerRef } = useScrollCtx()
   const [{ uniqueId, index, onDragStart, isActive, rect }, { active, hovering }, { lifecycle, ...internal }] = useReorder()
   const [posY, setPosY] = useState(null) // makes posY controlled (double render)

   /* Account for scrolled since drag start */
   // const [scrolledTop, setActiveScrolled] = useState(0)
   // const prevScrolledTop = useRef(scrolledY)
   const [activeScrolled, setActiveScrolled] = useState(0)
   const prevScrolled = useRef(scrolledY)
   useEffect(() => {
      // TODO smooth posY while scrolling
      updateScrollTop(prevScrolled.current)
      scrolledY !== prevScrolled.current && (prevScrolled.current = scrolledY)
   }, [scrolledY, isActive])

   const updateScrollTop = (prev: number) => {
      if (isActive) {
         setActiveScrolled((dy) => {
            return dy + scrolledY - prev // dy + diff since active
         })
      } else {
         setActiveScrolled(0)
      }
   }

   /* keep item z on top after drop */
   const wasPrevActiveRef = useRef(false)
   // prettier-ignore
   useEffect(() => {active.index !== -1 && (wasPrevActiveRef.current = isActive)}, [active.index])

   // TODO: observe resizes of items

   const isInScrollArea = (itmY: number) => {
      const ctn = containerRef.current.getBoundingClientRect()
      // Scroll top and scroll bottom
      const [scTop, scBtm] = [30, ctn.height - 30]
      console.log(itmY, itmY < scTop || itmY > scBtm)
      return itmY < scTop || itmY > scBtm
   }

   /* On scroll smooth transition (not triggered by drag on edge) */
   const [behaviourSmooth, setBehaviourSmooth] = useState(false)
   useEventListener("wheel", () => {
      if (!isActive || isInScrollArea(posY - scrolledY + rect.height - 15)) return
      // smooth scroll when from 0 => 130
      setBehaviourSmooth(false)
      setBehaviourSmooth(true)
   })
   useEffect(() => {
      setBehaviourSmooth(!isActive)
   }, [active.dy])

   /* Item motion react to Scroll / Drag / remapping */
   useEffect(() => {
      if (!rect || lifecycle === 0) internal.recalculateRects() // observer will compute rects after <Item> mounts

      const activeRef = internal.itemRefs.current[active.index]
      // Make room for empty slot (draggable new position)
      const direction = index > active.index ? -1 : 1
      const slotHeight = isBetween(index, active.index, hovering.index) ? direction * activeRef?.rect.height : 0
      /** Generated by elements above */
      const offsetTop = internal.itemRefs.current.slice(0, index).reduce((totalHeight, ref) => totalHeight + ref?.rect?.height, 0)
      // clamp to container boundary when dragging / floating
      const bounds = rect && boundClamp ? { min: scrolledY - 1, max: containerRef.current.clientHeight - rect.height + scrolledY + 1 } : {}

      const newPosY = isActive ? clamp(active.dy + offsetTop + activeScrolled, bounds) : offsetTop + slotHeight
      posY !== newPosY && setPosY(newPosY)
   }, [index, active, hovering, lifecycle, activeScrolled])

   return (
      <>
         {/* 1 Item */}
         <div
            ref={(node) => node && (internal.itemRefs.current[index] = { ...internal.itemRefs.current[index], node })}
            onMouseDown={(e) => draggable && onDragStart(e, uniqueId)}
            className={`z-6 w-100 ${isActive && styles.active} ${lifecycle >= 2 && styles.floating}`}
            style={{
               // Apply Floating layout once refs have settled
               position: lifecycle >= 1 ? "absolute" : "relative",
               height: lifecycle >= 1 && rect?.height,
               top: 0,
               transform: lifecycle >= 1 && `translateY(${posY}px)`,
               zIndex: wasPrevActiveRef.current && 5,
               transition: lifecycle >= 2 && behaviourSmooth ? "transform 130ms ease-in-out" : "",
            }}
         >
            <DragContext.Provider value={{ onDragStart: (e) => onDragStart(e, uniqueId), isActive }}>{children}</DragContext.Provider>
         </div>
         {/* 2 display block representation of item */}
         <div
            style={{
               display: lifecycle >= 1 ? "block" : "none",
               height: rect?.height,
               // opacity: uniqueId / 10,
               opacity: 0,
            }}
            className={`w-100 bg-red ${isActive && "reorder-slot-active"}`}
         />
      </>
   )
}

interface DragContextProps {
   onDragStart: (e: EventFor<MouseEvent>) => void
   /** Item being dragged */
   isActive: boolean
}

/** Individual item drag context */
const DragContext = createContext<DragContextProps | undefined>(undefined)

/** Custom Drag handle */
const useDragHandle = () => {
   const context = React.useContext(DragContext)
   if (!context) throw new Error("useCustomDrag must be used within a Reorder.Item")
   return context
}

export type { ItemProps, SourceProps }
export { Item, useDragHandle }
