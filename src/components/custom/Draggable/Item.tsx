// Dependencies
import React, { act, createContext, HTMLAttributes, ReactNode, useCallback, useEffect, useLayoutEffect, useMemo, useRef } from "react"
// Internal
import { isBetween } from "./utils"
import styles from "./draggable.module.scss"
import { useReorder } from "./Container"
// import { useScrollCtx } from "./CustomScroll"
import { clamp } from "@/utils"
// import { useEventListener } from "@/hooks/useEventListener"

/** Required props */
interface SourceProps {
   uniqueId: number
}

interface ItemProps extends SourceProps, HTMLAttributes<HTMLDivElement> {
   children: ReactNode
   /** Attach listener to item (alt: `use) */
   draggable?: boolean
   /** On item grab / drag clamp to container boundary */
   boundClamp?: boolean
}

// Misconception uniqueId might have empty steps, index represents the actual position
/** Reorder Item - slot sorted by uniqueId, relatively positioned by index */
function Item({ draggable, boundClamp = true, children, ...atts }: ItemProps) {
   // const { containerRef } = useScrollCtx()
   const [{ uniqueId, index, onDragStart, isActive, rect }, { active, hovering }, { ...internal }] = useReorder()

   /* 1 Item Positioning */

   // prettier-ignore
   const offset = useMemo(() => internal.itemsRef.current.slice(0, index).reduce((totalHeight, ref) => totalHeight + ref?.rect.height, 0), [index, internal.itemsRef.current])

   // Calculate Y position of item
   const calcPosY = useCallback(
      (diffScrolledY: number) => {
         // if (!rect || lifecycle === 0) internal.recalculateRects() // observer will compute rects after <Item> mounts

         const activeRect = internal.itemsRef.current[active.index]?.rect
         // Make room for empty slot (draggable new position)
         const direction = index > active.index ? -1 : 1
         const slotHeight = isBetween(index, active.index, hovering.index) ? direction * activeRect?.height : 0 // active height

         // return isActive ? clamp(active.dy + offsetTop + diffScrolledY, bounds) : offsetTop + slotHeight
         // return isActive ? active.dy + offsetTop + diffScrolledY : offsetTop + slotHeight
         return isActive ? active.dy + diffScrolledY + offset : slotHeight + offset
      },
      // [index, active.dy, hovering, lifecycle, bounds]
      [index, active.dy, offset, hovering, internal.itemsRef]
   )

   /* keep item z on top after drop */

   // Previous active item
   const wasPrevActiveRef = useRef(false)
   // prettier-ignore
   useEffect(() => {active.uniqueId !== -1 && (wasPrevActiveRef.current = isActive)}, [active.uniqueId])

   /* Item motion react to Scroll / Drag / remapping */

   // Generated by elements above
   // const offsetTop = useMemo(() => {
   //    console.warn("offsetTop", index, lifecycle)
   //    // return internal.itemsRef.current.slice(0, index).reduce((totalHeight, ref) => totalHeight + ref?.rect?.height, 0)
   //    return internal.itemsRect.slice(0, index).reduce((totalHeight, rect) => totalHeight + rect?.height, 0)
   // }, [index, lifecycle])

   // console.log(offsetTop)
   // // Item draggable Y clamp boundaries
   // const bounds = useMemo(() => {
   //    if (!(rect && boundClamp) || !containerRef.current) return {}
   //    return { min: scrolledY - 1, max: containerRef.current.clientHeight - rect.height + scrolledY + 1 }
   // }, [lifecycle, scrolledY])

   // TODO: Smooth translate3d on wheel scroll (custom motion with lerp & targetPos)

   // TODO: observe resizes of items

   return (
      <>
         {/* 1 Item */}
         <div
            ref={(node) => {
               if (node && internal.itemsRef.current[index]?.node !== node) {
                  const rect = node.getBoundingClientRect()
                  console.warn("recomputing rect for at ", uniqueId)
                  internal.itemsRef.current[index] = { node, rect }
                  // const tgt= internal.itemsRef.current[index]
                  // if (!tgt?.rect) {
                  //    console.log("updating item ref", uniqueId, index, node.getBoundingClientRect(), node)
                  //    internal.itemsRef.current[index] = {...tgt, rect: node.getBoundingClientRect()}
                  //    console.log(internal.itemsRef.current[index])
                  //    // setUpdate((prev) => prev + 1)
                  // }
                  // console.log("updating item ref", uniqueId, index, node.getBoundingClientRect(), node)
               }
            }}
            onMouseDown={(e) => draggable && onDragStart(e, uniqueId)}
            className={`z-6 w-100 ${isActive && styles.active} ${styles.floating} ${atts.className}`}
            style={{
               // Apply Floating layout once refs have settled
               // position: lifecycle >= 1 ? "absolute" : "relative",
               position: "absolute",
               // height: lifecycle >= 1 && rect?.height,
               top: 0,
               transform: `translateY(${calcPosY(active.scrolledY)}px)`,
               // transform: lifecycle >= 1 && `translateY(${topOffset}px)`,
               zIndex: wasPrevActiveRef.current && 5,
               // border: wasPrevActiveRef.current && "1px solid red",
               // transition: lifecycle >= 2 && behaviourSmooth ? "transform 130ms ease-in-out" : "",
               // transition: topOffset !== 0 && "none" // fix transition, goes from 0 to 100
            }}
         >
            <DragContext.Provider value={{ onDragStart: (e) => onDragStart(e, uniqueId), isActive }}>{children}</DragContext.Provider>
         </div>
         {/* 2 display block representation of item */}
         <div
            style={{
               // display: lifecycle >= 1 ? "block" : "none",
               display: "block",
               height: rect?.height,
            }}
            className={`w-100 ${isActive && "reorder-slot-active"}`}
         />
      </>
   )
}

interface DragContextProps {
   onDragStart: (e: EventFor<MouseEvent>) => void
   /** Item being dragged */
   isActive: boolean
}

/** Individual item drag context */
const DragContext = createContext<DragContextProps | undefined>(undefined)

/** Custom Drag handle */
const useDragHandle = () => {
   const context = React.useContext(DragContext)
   if (!context) throw new Error("useCustomDrag must be used within a Reorder.Item")
   return context
}

export type { ItemProps, SourceProps }
export { Item, useDragHandle }
